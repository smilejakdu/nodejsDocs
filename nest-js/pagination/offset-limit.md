# offset limit

TypeORM에서 페이지네이션을 구현할 때 가장 일반적인 방법은 `offset`과 `limit`을 사용하는 것입니다. 이 방법은 특정 페이지의 결과만큼 데이터를 건너뛰고(`offset`), 해당 페이지에 표시할 항목의 수(`limit`)를 지정하여 데이터를 조회합니다.

여기서 `offset`은 건너뛸 항목의 수를 나타내며, `limit`은 반환할 항목의 최대 수를 나타냅니다. 페이지네이션에서 `offset`은 현재 페이지 번호와 페이지당 항목 수를 곱하여 계산할 수 있습니다.

#### 예시:

고객 데이터가 있고, 한 페이지에 10개의 항목을 보여주려 할 때, 다음과 같이 페이지네이션을 할 수 있습니다.

* 첫 번째 페이지(`page = 1`)의 항목을 가져오려면:
  * `offset`은 `(1 - 1) * 10 = 0` (첫 번째 항목부터 시작)
  * `limit`은 `10`
* 두 번째 페이지(`page = 2`)의 항목을 가져오려면:
  * `offset`은 `(2 - 1) * 10 = 10` (11번째 항목부터 시작)
  * `limit`은 `10`

#### TypeORM 코드 예시:

```typescript
getRepository(Entity)
  .createQueryBuilder("alias")
  .skip((page - 1) * itemsPerPage) // offset
  .take(itemsPerPage) // limit
  .getManyAndCount();
```

`skip` 메서드는 건너뛸 항목의 수(`offset`)를 설정하고, `take` 메서드는 반환할 항목의 수(`limit`)를 설정합니다. `getManyAndCount` 메서드는 결과 배열과 전체 항목 수를 반환합니다. 전체 항목 수는 총 페이지 수를 계산하는 데 유용합니다.

#### 페이지네이션의 성능 고려사항:

`offset`과 `limit`을 사용하는 방법은 데이터가 많지 않을 때 잘 작동하지만, 많은 데이터가 있는 큰 테이블에서는 성능상의 문제가 있을 수 있습니다. `offset`이 클수록, 즉 건너뛰어야 할 데이터가 많아질수록 데이터베이스가 더 많은 작업을 해야 하고, 이로 인해 쿼리의

성능이 저하될 수 있습니다. 이는 데이터베이스가 `offset` 값만큼의 모든 행을 읽고 나서야 결과를 반환할 수 있기 때문입니다.

#### 성능 개선을 위한 대안:

* **인덱스 활용**: 페이징 쿼리의 성능을 향상시키기 위해, 쿼리가 사용하는 컬럼에 적절한 인덱스를 만드는 것이 중요합니다. 이렇게 하면 데이터베이스가 데이터를 빠르게 찾을 수 있습니다.
* **Keyset Pagination (커서 기반 페이지네이션)**: `offset` 대신 마지막으로 검색된 행의 키를 사용하여 다음 페이지를 조회하는 방법입니다. 예를 들어, ID 컬럼이 오름차순으로 정렬된 경우, 마지막으로 검색된 ID 이후의 행을 가져오는 방식입니다. 이 방법은 데이터베이스가 모든 이전 행을 읽을 필요 없이 더 효율적으로 다음 데이터 세트를 검색할 수 있도록 합니다.

```typescript
getRepository(Entity)
  .createQueryBuilder("alias")
  .where("alias.id > :lastId", { lastId: lastEntityId }) // lastEntityId는 마지막으로 가져온 엔티티의 ID입니다.
  .orderBy("alias.id", "ASC")
  .limit(itemsPerPage)
  .getMany();
```

위와 같은 커서 기반 페이지네이션은 특히 많은 양의 데이터를 다룰 때 `offset` 기반 페이지네이션보다 성능상 이점을 가집니다. 그러나 커서 기반 페이지네이션은 데이터가 자주 변경되거나 중간에 데이터가 삽입/삭제될 경우 적절한 데이터를 반환하지 못할 수 있으므로, 사용할 때는 이러한 제한 사항을 고려해야 합니다.

각 페이지네이션 전략은 사용 사례와 데이터 특성에 따라 달리 적용될 수 있으므로, 특정 상황에서 가장 적합한 방법을 선택하는 것이 중요합니다.
